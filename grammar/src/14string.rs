fn main() {

    // ========================================================================
    // &str 与 String
    // ========================================================================
    // Rust 的核心语言中只有一种字符串类型：str，字符串 slice，它通常以被借用的形式出现，&str。
    let japanese = "こんにちは";

    // 称作 String 的类型是由标准库提供的，而没有写进核心语言部分，它是可增长的、可变的、有所有权的、UTF-8 编码的字符串类型。
    // String 实际上是对Vec<u8>的包装
    let s = String::from("你好");  // 基于str创建String
    let s = japanese.to_string(); // str转String： to_string 方法能用于任何实现了 Display trait 的类型
    let s = "你好".to_string();    // 该方法也可直接用于字符串字面值：

    // String::from 和 .to_string 最终做了完全相同的工作，所以如何选择就是风格问题了


    // ========================================================================
    // 更新字符串
    // ========================================================================
    let mut s = String::new();  // 新建一个空的 String
    // push_str 方法采用字符串 slice，因为我们并不需要获取参数的所有权
    s.push_str("hello world"); // 使用 push_str 方法向 String 附加字符串 slice

    // push 方法被定义为获取一个单独的字符作为参数，并附加到 String 中
    s.push('!');

    // 使用 + 运算符或 format! 宏拼接字符串
    let s1 = String::from("Hello, ");
    let s2 = String::from("world!");
    let s3 = s1 + &s2; // 注意 s1 被移动了，不能继续使用
    /*
    执行完这些代码之后，字符串 s3 将会包含 Hello, world!。
    s1 在相加后不再有效的原因，和使用 s2 的引用的原因，与使用 + 运算符时调用的函数签名有关。
    + 运算符使用了 add 函数，这个函数签名看起来像这样：

    fn add(self, s: &str) -> String {}

    这并不是标准库中实际的签名；标准库中的 add 使用泛型定义。
    这里我们看到的 add 的签名使用具体类型代替了泛型，这也正是当使用 String 值调用这个方法会发生的。
    这个签名提供了理解 + 运算那微妙部分的线索。

    首先，s2 使用了 &，意味着我们使用第二个字符串的 引用 与第一个字符串相加。
    这是因为 add 函数的 s 参数：只能将 &str 和 String 相加，不能将两个 String 值相加。
    因此可知 let s3 = s1 + s2; 是不合法的。但是 &s2 的类型是 &String 而不是 &str，为何可以？
    ————之所以能够在 add 调用中使用 &s2 是因为 &String 可以被 强转（coerced）成 &str。
    当add函数被调用时，Rust 使用了一个被称为 解引用强制多态（deref coercion）的技术，你可以将其理解为它把 &s2 变成了 &s2[..]。
    因为 add 没有获取参数的所有权，所以 s2 在这个操作后仍然是有效的 String。

    其次，可以发现签名中 add 获取了 self 的所有权，因为 self 没有 使用 &。
    这意味着 s1 的所有权将被移动到 add 调用中，之后就不再有效。
    所以虽然 let s3 = s1 + &s2; 看起来就像它会复制两个字符串并创建一个新的字符串，
    而实际上这个语句会获取 s1 的所有权，附加上从 s2 中拷贝的内容，并返回结果的所有权。
    换句话说，它看起来好像生成了很多拷贝，不过实际上并没有：这个实现比拷贝要更高效。
    */

    // 对于更为复杂的字符串链接，可以使用 format! 宏，比 + 运算好理解的多：
    let s1 = String::from("tic");
    let s2 = String::from("tac");
    let s3 = String::from("toe");
    let s = format!("{}-{}-{}", s1, s2, s3);    // 不会出现所有权转移，因为使用了拷贝

    println!("{}-{}-{} => {}", s1, s2, s3, s);  //


    // ========================================================================
    // Rust 的字符串（str和String）不支持索引
    // ========================================================================
    /*
    原因一： UTF-8
    原因二： 从 Rust 的角度来讲，事实上有三种相关方式可以理解字符串：字节、标量值和字形簇（最接近人们眼中 字母 的概念）
    原因三： 索引操作预期总是需要常数时间 (O(1))。但是对于 String 不可能保证这样的性能，因为 Rust 必须从开头到索引位置遍历来确定有多少有效的字符。
    */


    // 切割字符串
    // 切割是允许的，但是必须沿着字符的边界进行切割(比如UTF-8的每个中文占三个字节)
    // 可以使用[]和一个范围来创建字符串的切片，使用时需要谨慎，因为切割如果跨越了字符边界程序就会 panic
    // 另外需要切割需要对字符串的字面值做操作，不是所有权。


    // ========================================================================
    // 遍历字符串的方法
    // ========================================================================
    /*
    用梵文书写的印度语单词 “नमस्ते”
    字节：[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135]
    Unicode标量值：['न', 'म', 'स', '्', 'त', 'े']    (第四个和第六个都不是字母，它们是发音符号本身并没有任何意义)
    字形簇: ["न", "म", "स्", "ते"]
    */

    // 遍历打印字节：
    for b in "नमस्ते".bytes() {
        print!("{} ", b);
    }
    println!();

    // 遍历打印Unicode标量值：
    for c in "नमस्ते".chars() {
        print!("{} ", c);
    }
    println!();


    // 遍历打印字形簇：还不知道怎么做 听说比较恶心
}