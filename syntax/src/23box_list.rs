fn main() {
    {
        // ========================================================================
        // 使用Box <T>指向堆上的数据
        // ========================================================================
        let b = Box::new(5);    // 这里定义了变量 b，其值是一个指向被分配在堆上的值 5 的 Box。
        println!("b = {}", b);  // 可以像数据是储存在栈上的那样访问 box 中的数据。
        // 正如任何拥有数据所有权的值那样，当像 b 这样的 box 在 main 的末尾离开作用域时，它将被释放。
        // 这个释放过程作用于 box 本身（位于栈上）和它所指向的数据（位于堆上）。
    }

    // ========================================================================
    // 像引用一样使用 Box<T>
    // ========================================================================
    // 常规引用是一个指针类型，一种理解指针的方式是将其看成指向储存在其他某处值的箭头。
    let x = 5;
    let y = &x;     // 指向 x 值的引用
    let z = Box::new(x);  // 指向 x 值的 box 实例

    assert_eq!(5, x);
    // 一旦解引用了 y，就可以访问 y 所指向的整型值并可以与 5 做比较。
    assert_eq!(5, *y);
    // 使用解引用运算符以 z 为引用时相同的方式追踪 box 的指针
    assert_eq!(5, *z);

    // assert_eq!(5, y);   // 编译错误：不允许比较数字的引用与数字，因为它们是不同的类型。必须使用解引用运算符追踪引用所指向的值。


    // ========================================================================
    // Box 允许创建递归类型 => 使用 Box<T> 给递归类型一个已知的大小
    // ========================================================================
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));

    println!("list = {:?}", list);  // 可以像数据是储存在栈上的那样访问 box 中的数据。
}

// ========================================================================
// Box 允许创建递归类型 => 使用 Box<T> 给递归类型一个已知的大小
// ========================================================================
/*
Rust 需要在编译时知道类型占用多少空间。一种无法在编译时知道大小的类型是 递归类型（recursive type），其值的一部分可以是相同类型的另一个值。
这种值的嵌套理论上可以无限的进行下去，所以 Rust 不知道递归类型需要多少空间。
不过 box 有一个已知的大小（usize），所以通过在循环类型定义中插入 box，就可以创建递归类型了。

cons list 是一个来源于 Lisp 编程语言及其方言的数据结构。
在 Lisp 中，cons 函数（“construct function" 的缩写）利用两个参数来构造一个新的列表，他们通常是一个单独的值和另一个列表。
cons 函数的概念涉及到更常见的函数式编程术语；“将 x 与 y 连接” 通常意味着构建一个新的容器而将 x 的元素放在新容器的开头，其后则是容器 y 的元素。
cons list 的每一项都包含两个元素：当前项的值和下一项。其最后一项值包含一个叫做 Nil 的值且没有下一项。cons list 通过递归调用 cons 函数产生。
代表递归的终止条件（base case）的规范名称是 Nil，它宣布列表的终止。
注意Rust的`Nil`这不同于其他语言(C/C++/Go)中的 “null” 或 “nil” 的概念，他们代表无效或缺失的值。

注意虽然函数式编程语言经常使用 cons list，但是它并不是一个 Rust 中常见的类型。
大部分在 Rust 中需要列表的时候，Vec<T> 是一个更好的选择。
其他更为复杂的递归数据类型 确实 在 Rust 的很多场景中很有用，不过通过以 cons list 作为开始，我们可以探索如何使用 box 毫不费力的定义一个递归数据类型。
*/
#[derive(Debug)]
enum List {
    // 如果不使用Box，编译器就会陷入一个无限的递归计算大小的过程，产生编译错误...
    // 而用Box套住List，参数二就是一个固定大小（usize）的指针值
    Cons(i32, Box<List>),
    Nil,
}

// 把List的两个值放到作用域就可以直接使用Cons和Nil，而不是List::Cons和List::Nil
use crate::List::{Cons, Nil};