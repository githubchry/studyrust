/*
// ========================================================================
// 生命周期避免了悬垂引用
// ========================================================================
// Rust 编译器有一个 借用检查器（borrow checker），它比较作用域来确保所有的借用都是有效的。
{
    //  Rust 确实不允许空值（悬垂引用），没有初始化的r并不算语法错误，因为编译器会根据下文判定r是否使用了空值
    let r;                // ---------+-- 'a
    {                     //          |
        let x = 5;        // --+- 'b  |
        r = &x;           //   |      |
    }                     // --+      |
    println!("r: {}", r); //          | => 编译错误：尝试使用离开作用域的值的引用（空值）
}                         // ---------+

这里将 r 的生命周期标记为 'a 并将 x 的生命周期标记为 'b。如你所见，内部的 'b 块要比外部的生命周期 'a 小得多。
在编译时，Rust 比较这两个生命周期的大小，并发现 r 拥有生命周期 'a，不过它引用了一个拥有生命周期 'b 的对象。
程序被拒绝编译，因为生命周期 'b 比生命周期 'a 要小：被引用的对象比它的引用者存在的时间更短。


// ========================================================================
// 函数中的泛型生命周期
// ========================================================================
// longest函数返回两个字符串 slice 中较长者
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

看起来没啥问题，实际编译器会返回一个有关生命周期的错误：
返回值需要一个泛型生命周期参数，因为 Rust 并不知道将要返回的引用是指向 x 或 y。
当我们定义这个函数的时候，并不知道传递给函数的具体值，所以也不知道到底是 if 还是 else 会被执行。
我们也不知道传入的引用的具体生命周期，所以也就不能像前面那样通过观察作用域来确定返回的引用是否总是有效。
借用检查器自身同样也无法确定，因为它不知道 x 和 y 的生命周期是如何与返回值的生命周期相关联的。
为了修复这个错误，我们将增加泛型生命周期参数来定义引用间的关系以便借用检查器可以进行分析。


// ========================================================================
// 生命周期注解语法
// ========================================================================
生命周期注解并不改变任何引用的生命周期的长短。
与当函数签名中指定了泛型类型参数后就可以接受任何类型一样，当指定了泛型生命周期后函数也能接受任何生命周期的引用。
生命周期注解描述了多个引用生命周期相互的关系，而不影响其生命周期。

生命周期注解有着一个不太常见的语法：生命周期参数名称必须以撇号（'）开头，其名称通常全是小写，类似于泛型其名称非常短。
'a 是大多数人默认使用的名称。生命周期参数注解位于引用的 & 之后，并有一个空格来将引用类型与生命周期注解分隔开。
&i32        // 引用
&'a i32     // 带有显式生命周期的引用
&'a mut i32 // 带有显式生命周期的可变引用

单个的生命周期注解本身没有多少意义，因为生命周期注解告诉 Rust 多个引用的泛型生命周期参数如何相互联系的。
例如如果函数有一个生命周期 'a 的 i32 的引用的参数 first。还有另一个同样是生命周期 'a 的 i32 的引用的参数 second。
这两个生命周期注解意味着引用 first 和 second 必须与这泛型生命周期存在得一样久。
简单说就是同一作用域内，带有相同生命周期注解的变量之间的生命周期相同。
// ========================================================================
// 函数签名中的生命周期注解
// ========================================================================
现在来看看 longest 函数的上下文中的生命周期。就像泛型类型参数，泛型生命周期参数需要声明在函数名和参数列表间的尖括号中。
这里我们想要告诉 Rust 关于参数中的引用和返回值之间的限制是他们都必须拥有相同的生命周期，所以需要在每个引用中都加上了 'a ：
*/
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
/*
泛型生命周期 'a 的具体生命周期等同于 x 和 y 的生命周期中较小的那一个。
因为我们用相同的生命周期参数 'a 标注了返回的引用值，所以返回的引用值就能保证在 x 和 y 中较短的那个生命周期结束之前保持有效。

当从函数返回一个引用，返回值的生命周期参数需要与一个参数的生命周期参数相匹配。
如果返回的引用 没有 指向任何一个参数，那么唯一的可能就是它指向一个函数内部创建的值，它将会是一个悬垂引用，因为它将会在函数结束时离开作用域。
尝试考虑这个并不能编译的 longest 函数实现：
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
编译失败: 因为返回值的生命周期与参数完全没有关联。

// ========================================================================
// 结构体定义中的生命周期注解
// ========================================================================
定义包含引用的结构体，`必须`为结构体定义中的每一个引用添加生命周期注解。
类似于泛型参数类型，必须在结构体名称后面的尖括号中声明泛型生命周期参数，以便在结构体定义中使用生命周期参数。

这个注解意味着 ImportantExcerpt 的实例不能比其 part 字段中的引用存在的更久
*/
struct ImportantExcerpt<'a> {
    part: &'a str,
}

/*
// ========================================================================
// 生命周期省略（Lifetime Elision）
// ========================================================================
08slice.rs里面写了一个first_word函数，签名是：
    fn first_word(s: &String) -> &str {
刚学玩生命周期可能会疑惑为什么它入参出参都是引用但没有生命周期注解，怎么能编译通过？
在早期版本（pre-1.0）的 Rust 中，这的确是不能编译的。每一个引用都必须有明确的生命周期。那时的函数签名将会写成这样：
    fn first_word<'a>(s: &'a str) -> &'a str {

在编写了很多 Rust 代码后，Rust 团队发现在特定情况下 Rust 程序员们总是重复地编写一模一样的生命周期注解。
这些场景是可预测的并且遵循几个明确的模式。
接着 Rust 团队就把这些模式编码进了 Rust 编译器中，如此借用检查器在这些情况下就能推断出生命周期而不再强制程序员显式的增加注解。

这里我们提到一些 Rust 的历史是因为更多的明确的模式被合并和添加到编译器中是完全可能的。未来只会需要更少的生命周期注解。

被编码进 Rust 引用分析的模式被称为 生命周期省略规则（lifetime elision rules）。
这并不是需要程序员遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。

省略规则并不提供完整的推断：如果 Rust 在明确遵守这些规则的前提下变量的生命周期仍然是模棱两可的话，它不会猜测剩余引用的生命周期应该是什么。
在这种情况，编译器会给出一个错误，这可以通过增加对应引用之间相联系的生命周期注解来解决。

函数或方法的参数的生命周期被称为 输入生命周期（input lifetimes），而返回值的生命周期被称为 输出生命周期（output lifetimes）。

编译器采用三条规则来判断引用何时不需要明确的注解。
第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。
如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。
这些规则适用于 fn 定义，以及 impl 块。

第一条规则是每一个是引用的参数都有它自己的生命周期参数。
换句话说就是，有一个引用参数的函数有一个生命周期参数：fn foo<'a>(x: &'a i32)，
有两个引用参数的函数有两个不同的生命周期参数，fn foo<'a, 'b>(x: &'a i32, y: &'b i32)，依此类推。

第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：fn foo<'a>(x: &'a i32) -> &'a i32。

第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 &self 或 &mut self，说明是个对象的方法(method)，
那么所有输出生命周期参数被赋予 self 的生命周期。第三条规则使得方法更容易读写，因为只需更少的符号。


// ========================================================================
// 方法定义中的生命周期注解
// ========================================================================
当为带有生命周期的结构体实现方法时，其语法亦需要使用生命周期注解。
声明和使用生命周期参数的位置依赖于生命周期参数是否同结构体字段或方法参数和返回值相关。
*/
impl<'a> ImportantExcerpt<'a> {
    // impl 之后和类型名称之后的生命周期参数是必要的，不过因为第一条生命周期规则我们并不必须标注 self 引用的生命周期。
    fn level(&self) -> i32 {
        3
    }

    // 这里是一个适用于第三条生命周期省略规则的例子：
    fn announce_and_return_part(&self, announcement: &str) -> &str {
        println!("Attention please: {}", announcement);
        self.part
    }
    // 这里有两个输入生命周期，所以 Rust 应用第一条生命周期省略规则并给予 &self 和 announcement 他们各自的生命周期。
    // 接着，因为其中一个参数是 &self，返回值类型被赋予了 &self 的生命周期，这样所有的生命周期都被计算出来了。
}


fn main() {
    // 函数签名中的生命周期注解
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);


    // 结构体中的生命周期注解
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.')
        .next()
        .expect("Could not find a '.'");
    let i = ImportantExcerpt { part: first_sentence };

    println!("{}", i.part);

    println!("level: {}", i.level());
    println!("{}", i.announce_and_return_part("hello world!"));


    // ========================================================================
    // 静态生命周期
    // ========================================================================
    // 这里有一种特殊的生命周期值得讨论：'static，其生命周期能够存活于整个程序期间。
    // 所有的字符串字面值都拥有 'static 生命周期，我们也可以选择像下面这样标注出来：
    let s: &'static str = "I have a static lifetime.";  // 显式声明静态
    let s = "I have a static lifetime.";    // 隐式声明静态 效果等同
    // 你可能在错误信息的帮助文本中见过使用 'static 生命周期的建议，不过将引用指定为 'static 之前，思考一下这个引用是否真的在整个程序的生命周期里都有效。
    // 你也许要考虑是否希望它存在得这么久，即使这是可能的。大部分情况，代码中的问题是尝试创建一个悬垂引用或者可用的生命周期不匹配，
    // 请解决这些问题而不是指定一个 'static 的生命周期。



    // ========================================================================
    // 结合泛型类型参数、trait bounds 和生命周期
    // ========================================================================
    // 在同一函数中指定泛型类型参数、trait bounds 和生命周期的语法：
    use std::fmt::Display;
    fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
        where T: Display
    {
        println!("Announcement! {}", ann);
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
    /*
    返回两个字符串 slice 中较长者的 longest 函数，不过带有一个额外的参数 ann。ann 的类型是泛型 T，
    它可以被放入任何实现了 where 从句中指定的 Display trait 的类型。
    这个额外的参数会在函数比较字符串 slice 的长度之前被打印出来，这也就是为什么 Display trait bound 是必须的。
    因为生命周期也是泛型，所以生命周期参数 'a 和泛型类型参数 T 都位于函数名后的同一尖括号列表中。
    */

    let string1 = String::from("abcd");
    let string2 = "xyz";
    let result = longest_with_an_announcement(string1.as_str(), string2, 123);
    println!("The longest string is {}", result);


}
