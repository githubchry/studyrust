/*
[不安全 Rust](https://rustwiki.org/zh-CN/book/ch19-01-unsafe-rust.html)

可以在不安全 Rust 中进行而不能用于安全 Rust 的操作:
    解引用裸指针
    调用不安全的函数或方法
    访问或修改可变静态变量
    实现不安全 trait
    访问 union 的字段

有一点很重要，unsafe 并不会关闭借用检查器或禁用任何其他 Rust 安全检查：如果在不安全代码中使用引用，它仍会被检查。
unsafe 关键字只是提供了那五个不会被编译器检查内存安全的功能。你仍然能在不安全块中获得某种程度的安全。

再者，unsafe 不意味着块中的代码就一定是危险的或者必然导致内存安全问题：其意图在于作为程序员你将会确保 unsafe 块中的代码以有效的方式访问内存。

人是会犯错误的，错误总会发生，不过通过要求这五类操作必须位于标记为 unsafe 的块中，就能够知道任何与内存安全相关的错误必定位于 unsafe 块内。
保持 unsafe 块尽可能小，如此当之后调查内存 bug 时就会感谢你自己了。

为了尽可能隔离不安全代码，将不安全代码封装进一个安全的抽象并提供安全 API 是一个好主意，当我们学习不安全函数和方法时会讨论到。
标准库的一部分被实现为在被评审过的不安全代码之上的安全抽象。
这个技术防止了 unsafe 泄露到所有你或者用户希望使用由 unsafe 代码实现的功能的地方，因为使用其安全抽象是安全的。
*/

fn main() {
    // ========================================================================
    // 解引用裸指针
    // ========================================================================
    /*
    unsafe rust 有两个被称为 裸指针（raw pointers）的类似于引用的新类型。
    和引用一样，裸指针是不可变或可变的，分别写作 *const T 和 *mut T。这里的星号不是解引用运算符；它是类型名称的一部分。
    在裸指针的上下文中，不可变 意味着指针解引用之后不能直接赋值。

    与引用和智能指针的区别在于，记住裸指针
        允许忽略借用规则，可以同时拥有不可变和可变的指针，或多个指向相同位置的可变指针
        不保证指向有效的内存
        允许为空
        不能实现任何自动清理功能
    通过去掉 Rust 强加的保证，你可以放弃安全保证以换取性能或使用另一个语言或硬件接口的能力，此时 Rust 的保证并不适用。
    */

    let mut num = 5;

    // 创建不可变和可变裸指针
    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;
    /*
    这里使用 as 将不可变和可变引用强转为对应的裸指针类型。
    因为直接从保证安全的引用来创建他们，可以知道这些特定的裸指针是有效，但是不能对任何裸指针做出如此假设。

    创建一个指向任意内存地址的裸指针。尝试使用任意内存是未定义行为：
    此地址可能有数据也可能没有，编译器可能会优化掉这个内存访问，或者程序可能会出现段错误（segmentation fault）。
    通常没有好的理由编写这样的代码，不过却是可行的：
    */
    let address = 0x012345usize;
    let r = address as *const i32;

    // 注意这里没有引入 unsafe 关键字。可以在安全代码中 创建 裸指针，只是不能在不安全块之外 解引用 裸指针。

    unsafe {
        // 通过裸指针，就能够同时创建同一地址的可变指针和不可变指针，若通过可变指针修改数据，则可能潜在造成数据竞争。请多加小心！
        *r2 = 10;
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);

        // println!("r is: {}", *r);   // 段错误：野指针访问
    }
    println!("num is: {}", num);

    // 既然存在这么多的危险，为何还要使用裸指针呢？一个主要的应用场景便是调用 C 代码接口(调用不安全函数或方法)，另一个场景是构建借用检查器无法理解的安全抽象。

    // ========================================================================
    // 调用不安全的函数或方法
    // ========================================================================
    // 创建不安全的函数：使用unsafe声明
    unsafe fn dangerous() {}

    // 调用不安全的函数：在unsafe代码块中调用
    unsafe {
        dangerous();
    }

    // ------------------------------------------------------------------------
    // 创建不安全代码的安全抽象
    // ------------------------------------------------------------------------
    /*
    仅仅因为函数包含不安全代码并不意味着整个函数都需要标记为不安全的。事实上，将不安全代码封装进安全函数是一个常见的抽象。
    作为一个例子，标准库中的函数，split_at_mut，它需要一些不安全代码，让我们探索如何可以实现它。
    这个安全函数定义于可变 slice 之上：它获取一个 slice 并从给定的索引参数开始将其分为两个 slice。
    先看看split_at_mut的用法：
    */
    let mut v = vec![1, 2, 3, 4, 5, 6];
    let r = &mut v[..];
    let (a, b) = r.split_at_mut(3);
    assert_eq!(a, &mut [1, 2, 3]);
    assert_eq!(b, &mut [4, 5, 6]);

    // 出于简单考虑，我们将 split_at_mut 实现为函数而不是方法，并只处理 i32 值而非泛型 T 的 slice。
    use std::slice;

    fn split_at_mut(slice: &mut [i32], mid: usize) -> (&mut [i32], &mut [i32]) {
        let len = slice.len();

        // 通过增加 mid 必然小于等于 len 的断言，我们可以说 unsafe 块中所有的裸指针将是有效的 slice 中数据的指针。这是一个可以接受的 unsafe 的恰当用法。
        assert!(mid <= len);

        // return (&mut slice[..mid], &mut slice[mid..]); //编译错误：
        // Rust 的借用检查器不能理解我们要借用这个 slice 的两个不同部分：它只知道我们借用了同一个 slice 两次。
        // 本质上借用 slice 的不同部分是可以的，因为结果两个 slice 不会重叠，不过 Rust 还没有智能到能够理解这些。
        // 当我们知道某些事是可以的而 Rust 不知道的时候，就是触及不安全代码的时候了：

        let ptr = slice.as_mut_ptr();   // 使用 as_mut_ptr 方法访问 slice 的裸指针
        // 因为slice是一个 i32 值的可变 slice，所以as_mut_ptr 返回一个 *mut i32 类型的裸指针，储存在 ptr 变量中。

        unsafe {
            // slice::from_raw_parts_mut 函数获取一个裸指针和一个长度来创建一个 slice。
            // 然后在 ptr 上调用 add 方法并使用 mid 作为参数来获取一个从 mid 开始的裸指针，使用这个裸指针并以 mid 之后项的数量为长度创建一个 slice。
            (slice::from_raw_parts_mut(ptr, mid), slice::from_raw_parts_mut(ptr.add(mid), len - mid))
            // slice::from_raw_parts_mut 函数是不安全的因为它获取一个裸指针，并必须确信这个指针是有效的。
            // 裸指针上的 add 方法也是不安全的，因为其必须确信此地址偏移量也是有效的指针。
        }
    }

    let mut v = vec![1, 2, 3, 4, 5, 6];
    let r = &mut v[..];
    let (a, b) = split_at_mut(r, 3);
    assert_eq!(a, &mut [1, 2, 3]);
    assert_eq!(b, &mut [4, 5, 6]);

    // ------------------------------------------------------------------------
    // 使用 extern 函数调用外部代码
    // ------------------------------------------------------------------------
    /*
    有时你的 Rust 代码可能需要与其他语言编写的代码交互。
    为此 Rust 有一个关键字，extern，有助于创建和使用 外部函数接口（Foreign Function Interface， FFI）。
    外部函数接口是一个编程语言用以定义函数的方式，其允许不同（外部）编程语言调用这些函数。

    下面展示了如何集成 C 标准库中的 abs 函数。extern 块中声明的函数在 Rust 代码中总是不安全的。
    因为其他语言不会强制执行 Rust 的规则且 Rust 无法检查它们，所以确保其安全是程序员的责任：
    */
    extern "C" {
        fn abs(input: i32) -> i32;
    }
    /*
    在 extern "C" 块中，列出了我们希望能够调用的另一个语言中的外部函数的签名和名称。
    "C" 部分定义了外部函数所使用的 应用二进制接口（application binary interface，ABI） —— ABI 定义了如何在汇编语言层面调用此函数。
    "C" ABI 是最常见的，并遵循 C 编程语言的 ABI。
    */

    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }


    // ------------------------------------------------------------------------
    // 从其它语言调用 Rust 函数
    // ------------------------------------------------------------------------
    /*
    使用 extern 来创建一个允许其他语言调用 Rust 函数的接口。不同于 extern 块，就在 fn 关键字之前增加 extern 关键字并指定所用到的 ABI。
    还需增加 #[no_mangle] 注解来告诉 Rust 编译器不要 mangle 此函数的名称。
    Mangling 发生于当编译器将我们指定的函数名修改为不同的名称时，这会增加用于其他编译过程的额外信息，不过会使其名称更难以阅读。
    每一个编程语言的编译器都会以稍微不同的方式 mangle 函数名，所以为了使 Rust 函数能在其他语言中指定，必须禁用 Rust 编译器的 name mangling。

    在如下的例子中，一旦其编译为动态库并从 C 语言中链接，call_from_c 函数就能够在 C 代码中访问：
    */
    #[no_mangle]
    pub extern "C" fn call_from_c() {
        println!("Just called a Rust function from C!");
    }
    // extern 的使用无需 unsafe。


    // ========================================================================
    // 访问或修改可变静态变量
    // ========================================================================
    /*
    目前为止全书都尽量避免讨论 全局变量（global variables），Rust 确实支持他们，不过这对于 Rust 的所有权规则来说是有问题的。
    如果有两个线程访问相同的可变全局变量，则可能会造成数据竞争。

    全局变量在 Rust 中被称为 静态（static）变量。
    */
    // 一个拥有字符串 slice 值的静态变量的声明和应用：
    static HELLO_WORLD: &str = "Hello, world!";

    println!("name is: {}", HELLO_WORLD);
    /*
    static 变量类似于常量。通常静态变量的名称采用 大写蛇形命名SCREAMING_SNAKE_CASE 写法，并 必须 标注变量的类型，在这个例子中是 &'static str。
    静态变量只能储存拥有 'static 生命周期的引用，这意味着 Rust 编译器可以自己计算出其生命周期而无需显式标注。访问不可变静态变量是安全的。

    常量与不可变静态变量可能看起来很类似，不过一个微妙的区别是静态变量中的值有一个固定的内存地址。
    使用这个值总是会访问相同的地址。另一方面，常量则允许在任何被用到的时候复制其数据。

    常量与静态变量的另一个区别在于静态变量可以是可变的。访问和修改可变静态变量都是 不安全 的。
    下面展示了如何声明、访问和修改名为 COUNTER 的可变静态变量：
    */
    static mut COUNTER: u32 = 0;

    fn add_to_count(inc: u32) {
        unsafe {
            // 任何读写 静态变量 的代码都必须位于 unsafe 块中
            COUNTER += inc;
        }
    }
    add_to_count(3);

    // 任何读写 静态变量 的代码都必须位于 unsafe 块中
    // println!("COUNTER: {}", COUNTER);   // ERROR: Use of mutable static is unsafe and requires unsafe function or block
    unsafe {
        println!("COUNTER: {}", COUNTER);
    }
    // 拥有可以全局访问的可变数据，难以保证不存在数据竞争，这就是为何 Rust 认为可变静态变量是不安全的。
    // 任何可能的情况，请优先使用并发技术和线程安全智能指针，这样编译器就能检测不同线程间的数据访问是否是安全的。


    // ========================================================================
    // 实现不安全 trait
    // ========================================================================
    // 当至少有一个方法中包含编译器不能验证的不变量时 trait 是不安全的。
    // 可以在 trait 之前增加 unsafe 关键字将 trait 声明为 unsafe，同时 trait 的实现也必须标记为 unsafe，
    unsafe trait Foo {
        // methods go here
    }

    // 通过 unsafe impl，我们承诺将保证编译器所不能验证的不变量。

    unsafe impl Foo for i32 {
        // method implementations go here
    }

    /*
    32thread_mutex.rs末尾关于`Sync 和 Send trait`的学习中提到，通过实现 Send trait 允许在线程间转移所有权。
    而几乎所有基本类型都是 Send 的，除了裸指针（raw pointer）。手动实现 Send 和 Sync 是不安全的。
    如果实现了一个包含一些不是 Send 或 Sync 的类型，比如裸指针，并希望将此类型标记为 Send 或 Sync，则必须使用 unsafe。
    Rust 不能验证我们的类型保证可以安全的跨线程发送或在多线程间访问，所以需要我们自己进行检查并通过 unsafe 表明。
    */


    // ========================================================================
    // 访问 union 的字段
    // ========================================================================
    // union 和 struct 类似，但是在一个实例中同时只能使用一个声明的字段。联合体主要用于和 C 代码中的联合体交互。
    // 访问联合体的字段是不安全的，因为 Rust 无法保证当前存储在联合体实例中数据的类型。
    union MyUnion {
        uint8: u8,
        int8: i8,
    }
    let mut my_union = MyUnion { int8: -1 };
    let uint8 = unsafe { my_union.uint8 };
    let int8 = unsafe { my_union.int8 };

    println!("uint8: {}", uint8);
    println!("int8: {}", int8);
}