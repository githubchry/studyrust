
/*
12match_if-let.rs学习了模式的概念，现在对其进行补充：学习所有可能会用到模式的位置

复习：

match 分支
match 表达式必须是 穷尽（exhaustive）的，意为 match 表达式所有可能的值都必须被考虑到。
一个确保覆盖每个可能值的方法是在最后一个分支使用捕获所有的模式：比如，一个匹配任何值的名称永远也不会失败，因此可以覆盖所有匹配剩下的情况。
有一个特定的模式 _ 可以匹配所有情况，不过它从不绑定任何变量。

if let 条件表达式
主要用于编写等同于只关心一个情况的 match 语句简写的。if let 可以对应一个可选的带有代码的 else 在 if let 中的模式不匹配时运行。
if let 表达式的缺点在于其穷尽性没有为编译器所检查，而 match 表达式则检查了。
*/

fn main() {
    // 代码展示了一系列针对不同条件的检查来决定背景颜色应该是什么。为了达到这个例子的目的，我们创建了硬编码值的变量，在真实程序中则可能由询问用户获得。
    // 如果用户指定了中意的颜色，将使用其作为背景颜色。
    // 如果今天是星期二，背景颜色将是绿色。
    // 如果用户指定了他们的年龄字符串并能够成功将其解析为数字的话，我们将根据这个数字使用紫色或者橙色。
    // 最后，如果没有一个条件符合，背景颜色将是蓝色：
    // 这个条件结构允许我们支持复杂的需求。

    let favorite_color: Option<&str> = None;
    let is_tuesday = false;
    let age: Result<u8, _> = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {}, as the background", color);
    } else if is_tuesday {
        println!("Tuesday is green day!");
    } else if let Ok(age) = age {
        /*
        注意 if let 也可以像 match 分支那样引入覆盖变量：if let Ok(age) = age 引入了一个新的覆盖变量 age，它包含 Ok 成员中的值。
        这意味着 if age > 30 条件需要位于这个代码块内部；不能将两个条件组合为 if let Ok(age) = age && age > 30，
        因为我们希望与 30 进行比较的被覆盖的 age 直到大括号开始的新作用域才是有效的。
        */

        if age > 30 {
            println!("Using purple as the background color");
        } else {
            println!("Using orange as the background color");
        }
    } else {
        // if let 表达式的缺点在于其穷尽性没有为编译器所检查，而 match 表达式则检查了。
        // 如果去掉最后的这个 else 块而遗漏处理一些情况，编译器也不会警告这类可能的逻辑错误。
        println!("Using blue as the background color");
    }


    // ========================================================================
    // while let 条件循环
    // ========================================================================
    // 一个与 if let 结构类似的是 while let 条件循环，它允许只要模式匹配就一直进行 while 循环。
    let mut stack = Vec::new();

    stack.push(1);
    stack.push(2);
    stack.push(3);
    // pop 方法取出 vector 的最后一个元素并返回 Some(value)。
    // 如果 vector 是空的，它返回 None。while 循环只要 pop 返回 Some 就会一直运行其块中的代码。
    // 一旦其返回 None，while 循环停止。我们可以使用 while let 来弹出栈中的每一个元素。
    while let Some(top) = stack.pop() {
        println!("{}", top);
    }

    // ========================================================================
    // for 循环
    // ========================================================================
    // for 可以获取一个模式。在 for 循环中，模式是 for 关键字直接跟随的值，正如 for x in y 中的 x。
    let v = vec!['a', 'b', 'c'];

    // 这里使用 enumerate 方法适配一个迭代器来产生一个值和其在迭代器中的索引，他们位于一个元组中。
    // 第一个 enumerate 调用会产生元组 (0, 'a')。
    // 当这个元组值匹配模式 (index, value)，index 将会是 0 而 value 将会是 'a'，并打印出第一行输出。
    for (index, value) in v.iter().enumerate() {
        println!("{} is at index {}", value, index);
    }

    // ========================================================================
    // let 语句
    // ========================================================================
    /*
    let 语句更为正式的样子如下：
        let PATTERN = EXPRESSION;
    学习至今已经进行了不下百次这样的操作，不过你可能没有发觉，这正是在使用模式！

    像 let x = 5; 这样的语句中变量名位于 PATTERN 位置，变量名不过是形式特别朴素的模式。
    我们将表达式与模式比较，并为任何找到的名称赋值。所以例如 let x = 5; 的情况，x 是一个模式代表 “将匹配到的值绑定到变量 x”。
    同时因为名称 x 是整个模式，这个模式实际上等于 “将任何值绑定到变量 x，不管值是什么”。
    */

    // 为了更清楚的理解 let 的模式匹配方面的内容，考虑使用 let 和模式解构一个元组：
    let (x, y, z) = (1, 2, 3);  // 使用模式解构元组并一次创建三个变量
    // 这里将一个元组与模式匹配。Rust 会比较值 (1, 2, 3) 与模式 (x, y, z) 并发现此值匹配这个模式。
    // 在这个例子中，将会把 1 绑定到 x，2 绑定到 y 并将 3 绑定到 z。
    // 你可以将这个元组模式看作是将三个独立的变量模式结合在一起。

    // 如果希望忽略元组中一个或多个值，也可以使用 _ 或 ..
    let (x, y, _) = (1, 2, 3);   // 使用 _ 忽略整个值
    let ( .., z) = (1, 2, 3);         // 使用 .. 忽略整个值


    // ========================================================================
    // 函数参数
    // ========================================================================
    /*
    函数参数也可以是模式。下面代码声明了一个叫做 foo 的函数，它获取一个 i32 类型的参数 x，现在这看起来应该很熟悉：
        fn foo(x: i32) {
            // 代码
        }
    x 部分就是一个模式！类似于之前对 let 所做的，可以在函数参数中匹配元组。下面将传递给函数的元组拆分为值：
    */
    fn print_coordinates(&(x, y): &(i32, i32)) {
        println!("Current location: ({}, {})", x, y);
    }
    let point = (3, 5);
    print_coordinates(&point);
    // 这会打印出 Current location: (3, 5)。值 &(3, 5) 会匹配模式 &(x, y)，如此 x 得到了值 3，而 y得到了值 5。

    // 因为闭包类似于函数，也可以在闭包参数列表中使用模式。


    // ========================================================================
    // 模式的两种形式：refutable（可反驳的）和 irrefutable（不可反驳的）
    // ========================================================================
    /*
    能匹配任何传递的可能值的模式被称为是 不可反驳的（irrefutable）。意味着他们必须匹配所提供的任何值。
        一个例子就是 let x = 5; 语句中的 x，因为 x 可以匹配任何值所以不可能会失败。

    对某些可能的值进行匹配会失败的模式被称为是 可反驳的（refutable）。
        一个这样的例子便是 if let Some(x) = a_value 表达式中的 Some(x)；
        如果变量 a_value 中的值是 None 而不是 Some，那么 Some(x) 模式不能匹配。


    函数参数、 let 语句和 for 循环只能接受不可反驳的模式，因为通过不匹配的值程序无法进行有意义的工作。
    if let 和 while let 表达式被限制为只能接受可反驳的模式，因为根据定义他们意在处理可能的失败：条件表达式的功能就是根据成功或失败执行不同的操作。

    尝试在 Rust 要求不可反驳模式的地方使用可反驳模式以及相反情况的例子:
        let Some(x) = some_option_value; // 编译错误：let 语句只能接受不可反驳模式因为代码不能通过 None 值进行有效的操作

    为了修复在需要不可反驳模式的地方使用可反驳模式的情况，可以修改使用模式的代码：不同于使用 let，可以使用 if let。
    如此，如果模式不匹配，大括号中的代码将被忽略，其余代码保持有效:
    */
    let some_option_value: Option<&str> = Some("Hello");
    // let some_option_value: Option<&str> = None;
    if let Some(x) = some_option_value {
        println!("{}", x);
    }

    // 如果为 if let 提供了一个总是会匹配的模式，编译器会给出一个警告：Rust 会抱怨将不可反驳模式用于 if let 是没有意义的：
    if let x = 5 {
        println!("{}", x);
    };

    // 基于此，match匹配分支必须使用可反驳模式，除了最后一个分支需要使用能匹配任何剩余值的不可反驳模式。
    // Rust允许我们在只有一个匹配分支的match中使用不可反驳模式，不过这么做不是特别有用，并可以被更简单的 let 语句替代。
}