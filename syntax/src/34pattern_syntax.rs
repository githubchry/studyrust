/*
收集了模式中所有有效的语法，并讨论了为什么可能要使用每个语法。
*/

fn main() {
    // ========================================================================
    // 匹配字面值
    // ========================================================================
    // 这段代码会打印 one 因为 x 的值是 1。如果希望代码获得特定的具体值，则该语法很有用。
    let x = 1;

    match x {
        1 => println!("one"),
        2 => println!("two"),
        3 => println!("three"),
        _ => println!("anything"),
    }

    // ========================================================================
    // 匹配命名变量
    // ========================================================================
    // 命名变量是匹配任何值的不可反驳模式，这在之前已经使用过数次。然而当其用于 match 表达式时情况会有些复杂。
    // 因为 match 会开始一个新作用域，match 表达式中作为模式的一部分声明的变量会覆盖 match 结构之外的同名变量，与所有变量一样。

    let x = Some(5);
    // let x = Some(50);
    // let x = None;
    let y = 10;

    match x {
        Some(50) => println!("Got 50, x = {:?}, y = {:?}", x, y),
        Some(y) => println!("Matched, 注意此时外面的y已经被覆盖了：y = {:?}", y),
        /*
        匹配分支Some(y)中的模式引入了一个新变量 y，它会匹配任何 Some 中的值。
        因为我们在 match 表达式的新作用域中，这是一个新变量，而不是开头声明为值 10 的那个 y。
        这个新的 y 绑定会匹配任何 Some 中的值，在这里是 x 中的值。因此这个 y 绑定了 x 中 Some 内部的值。
        */
        _ => println!("Default case, x = {:?}, y = {:?}", x, y),

        // 一旦 match 表达式执行完毕，其作用域也就结束了，同理内部 y 的作用域也结束了。
    }

    println!("at the end: x = {:?}, y = {:?}", x, y);

    // 为了创建能够比较外部 x 和 y 的值，而不引入覆盖变量的 match 表达式，我们需要相应地使用带有条件的匹配守卫（match guard）。
    // 关于匹配守卫（match guard），在本文件末尾介绍

    // ========================================================================
    // 多个模式
    // ========================================================================
    // 在 match 表达式中，可以使用 | 语法匹配多个模式，它代表 或（or）的意思。
    // 例如，如下代码将 x 的值与匹配分支相比较，第一个分支有 或 选项，意味着如果 x 的值匹配此分支的任一个值，它就会运行：
    let x = 1;

    match x {
        1 | 2 => println!("one or two"),
        3 => println!("three"),
        _ => println!("anything"),
    }

    // ========================================================================
    // 通过 ..= 匹配值的范围
    // ========================================================================
    // ..= 语法允许你匹配一个闭区间范围内的值。在如下代码中，当模式匹配任何在此范围内的值时，该分支会执行：
    let x = 2;

    match x {
        1..=5 => println!("one through five"),
        _ => println!("something else"),
    }
    // 如果 x 是 1、2、3、4 或 5，第一个分支就会匹配。这相比使用 | 运算符表达相同的意思更为方便；
    // 相比 1..=5，使用 | 则不得不指定 1 | 2 | 3 | 4 | 5。相反指定范围就简短的多，特别是在希望匹配比如从 1 到 1000 的数字的时候！

    // 范围只允许用于数字或 char 值，因为编译器会在编译时检查范围不为空。char 和 数字值是 Rust 仅有的可以判断范围是否为空的类型。
    let x = 'c';

    match x {
        'a'..='j' => println!("early ASCII letter"),
        'k'..='z' => println!("late ASCII letter"),
        _ => println!("something else"),
    }

    // ========================================================================
    // 解构并分解值
    // ========================================================================
    // 也可以使用模式来解构结构体、枚举、元组和引用，以便使用这些值的不同部分。

    // ------------------------------------------------------------------------
    // 解构结构体
    // ------------------------------------------------------------------------
    struct Point {
        x: i32,
        y: i32,
    }
    let p = Point { x: 0, y: 7 };

    // 创建了变量 a 和 b 来匹配结构体 p 中的 x 和 y 字段, 注意创建的是a/b而不是Point！！！
    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);

    // 模式中的变量名不必与结构体中的字段名一致。不过通常希望变量名与字段名一致以便于理解变量来自于哪些字段。
    // 因为变量名匹配字段名是常见的，同时因为 let Point { x: x, y: y } = p; 包含了很多重复，
    // 所以对于匹配结构体字段的模式存在简写：只需列出结构体字段的名称，则模式创建的变量会有相同的名称。
    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);

    // 也可以使用字面值作为结构体模式的一部分进行进行解构，而不是为所有的字段创建变量。这允许我们测试一些字段为特定值的同时创建其他字段的变量。
    // 下面展示一个 match 语句将 Point 值分成了三种情况：直接位于 x 轴上（此时 y = 0 为真）、位于 y 轴上（x = 0）或不在任何轴上的点。
    match p {
        Point { x, y: 0 } => println!("On the x axis at {}", x),
        Point { x: 0, y } => println!("On the y axis at {}", y),
        Point { x, y } => println!("On neither axis: ({}, {})", x, y),
    }

    // ------------------------------------------------------------------------
    // 解构枚举
    // ------------------------------------------------------------------------
    // 解构枚举的模式 需要对应 枚举所定义的储存数据的方式
    enum Message {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(i32, i32, i32),
    }
    // let msg = Message::Move{ x, y };
    // let msg = Message::Write(String::from("0, 160, 255"));
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit => {
            println!("The Quit variant has no data to destructure.");
            println!("The Quit variant has no data to destructure.")
            // 作用域最后一行语句的分号可有可无
        }
        Message::Move { x, y } => {
            println!("Move in the x direction {} and in the y direction {}", x, y)
        }
        Message::Write(text) => println!("Text message: {}", text),
        Message::ChangeColor(r, g, b) => {
            println!("Change the color to red {}, green {}, and blue {}", r, g, b)
        }
    }

    // ------------------------------------------------------------------------
    // 解构嵌套的结构体和枚举
    // ------------------------------------------------------------------------
    enum Color {
        Rgb(i32, i32, i32),
        Hsv(i32, i32, i32),
    }

    enum MessageEx {
        Quit,
        Move { x: i32, y: i32 },
        Write(String),
        ChangeColor(Color),
    }
    let msg = MessageEx::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        MessageEx::ChangeColor(Color::Rgb(r, g, b)) => {
            println!("Change the color to red {}, green {}, and blue {}", r, g, b)
        }
        MessageEx::ChangeColor(Color::Hsv(h, s, v)) => {
            println!("Change the color to hue {}, saturation {}, and value {}", h, s, v)
        }
        _ => ()
    }

    // ------------------------------------------------------------------------
    // 解构结构体和元组
    // ------------------------------------------------------------------------
    // 甚至可以用复杂的方式来混合、匹配和嵌套解构模式。如下是一个复杂结构体的例子，其中结构体和元组嵌套在元组中，并将所有的原始类型解构出来：
    let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
    println!("feet = {}, inches = {}, x = {}, y = {}, ", feet, inches, x, y);

    // ========================================================================
    // 忽略模式中的值
    // ========================================================================


    // ------------------------------------------------------------------------
    // 使用 _ 忽略整个值
    // ------------------------------------------------------------------------
    // 我们已经使用过下划线（_）作为匹配但不绑定任何值的通配符模式了。
    // 虽然 _ 模式作为 match 表达式最后的分支特别有用，也可以将其用于任意模式，包括函数参数中
    fn foo(_: i32, y: i32) {
        println!("This code only uses the y parameter: {}", y);
    }

    foo(3, 4);
    // 大部分情况当你不再需要特定函数参数时，最好修改签名不再包含无用的参数。
    // 在一些情况下忽略函数参数会变得特别有用，比如实现 trait 时，当你需要特定类型签名但是函数实现并不需要某个参数时。
    // 此时编译器就不会警告说存在未使用的函数参数，就跟使用命名参数一样。


    // ------------------------------------------------------------------------
    // 使用嵌套的 _ 忽略部分值
    // ------------------------------------------------------------------------
    // 也可以在一个模式内部使用_ 忽略部分值，例如，当只需要测试部分值但在期望运行的代码中没有用到其他部分时。
    // 展示负责管理设置值的代码。业务需求是用户不允许覆盖现有的自定义设置，但是可以取消设置，也可以在当前未设置时为其提供设置。
    let mut setting_value = Some(5);
    let new_setting_value = Some(10);
    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) => {
            // setting_value和new_setting_value都不是None的情况
            println!("Can't overwrite an existing customized value");
        }
        _ => {
            setting_value = new_setting_value;
        }
    }

    println!("setting is {:?}", setting_value);

    // 也可以在一个模式中的多处使用下划线来忽略特定值，这里忽略了一个五元元组中的第二和第四个值：
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, _, third, _, fifth) => {
            println!("Some numbers: {}, {}, {}", first, third, fifth)
        },
    }



    // ------------------------------------------------------------------------
    // 通过在名字前以一个下划线开头来忽略未使用的变量
    // ------------------------------------------------------------------------
    // 如果你创建了一个变量却不在任何地方使用它, Rust 通常会给你一个警告，因为这可能会是个 bug。
    // 但是有时创建一个还未使用的变量是有用的，比如你正在设计原型或刚刚开始一个项目。
    // 这时你希望告诉 Rust 不要警告未使用的变量，为此可以用下划线作为变量名的开头。
    let _x = 5;      // 不会产生编译警告
    let y = 10; // 编译警告：未使用变量 y

    /*
    注意, 只使用 _ 和使用以下划线开头的名称有些微妙的不同：比如 _x 仍会将值绑定到变量，而 _ 则完全不会绑定：
        let s = Some(String::from("Hello!"));
        if let Some(_s) = s {      // 编译错误：因为 s 的值仍然会移动进 _s，并阻止我们再次使用 s
            println!("found a string");
        }
        println!("{:?}", s);
    */
    let s = Some(String::from("Hello!"));

    if let Some(_) = s {
        println!("found a string");
    }
    // 上面的代码能很好的运行；因为没有把 s 绑定到任何变量；它没有被移动。
    println!("{:?}", s);


    // ------------------------------------------------------------------------
    // 用 .. 忽略剩余值
    // ------------------------------------------------------------------------
    // 对于有多个部分的值，可以使用 .. 语法来只使用部分并忽略其它值，同时避免不得不每一个忽略值列出下划线。
    // .. 模式会忽略模式中剩余的任何没有显式匹配的值部分。
    // 有一个 Point 结构体存放了三维空间中的坐标。在 match 表达式中，我们希望只操作 x 坐标并忽略 y 和 z 字段的值：
    struct PointEx {
        x: i32,
        y: i32,
        z: i32,
    }

    let origin = PointEx { x: 0, y: 0, z: 0 };
    match origin {
        // 这里列出了 x 值，接着仅仅包含了 .. 模式。这比不得不列出 y: _ 和 z: _ 要来得简单，
        // 特别是在处理有很多字段的结构体，但只涉及一到两个字段时的情形。
        PointEx { x, .. } => println!("x is {}", x),
    }

    // 用 first 和 last 来匹配第一个和最后一个值。.. 将匹配并忽略中间的所有值。
    let numbers = (2, 4, 8, 16, 32);
    match numbers {
        (first, .., last) => {
            println!("Some numbers: {}, {}", first, last);
        },
    }

    /*
    然而使用 .. 必须是无歧义的。如果期望匹配和忽略的值是不明确的，Rust 会报错。下面展示了一个带有歧义的 .. 例子，因此其不能编译：
        let numbers = (2, 4, 8, 16, 32);
        match numbers {
            (.., second, ..) => {   // 编译错误： `..` can only be used once per tuple or tuple struct pattern
                println!("Some numbers: {}", second)
            },
        }
    Rust 不可能决定在元组中匹配 second 值之前应该忽略多少个值，以及在之后忽略多少个值。
    */


    // ========================================================================
    // 匹配守卫提供的额外条件
    // ========================================================================
    // 匹配守卫（match guard）是一个指定于 match 分支模式之后的额外 if 条件，它也必须被满足才能选择此分支。
    // 匹配守卫用于表达比单独的模式所能允许的更为复杂的情况。这个条件可以使用模式中创建的变量。
    let num = Some(4);
    // 下面展示了一个 match，其中第一个分支有模式 Some(x) 还有匹配守卫 if x < 5：
    match num {
        Some(x) if x < 5 => println!("less than five: {}", x),
        Some(x) => println!("{}", x),
        None => (),
    }
    /*
    当 num 与模式中第一个分支比较时，因为 Some(4) 匹配 Some(x) 所以可以匹配。
    接着匹配守卫检查 x 值是否小于 5，因为 4 小于 5，所以第一个分支被选择。

    相反如果 num 为 Some(10)，因为 10 不小于 5 所以第一个分支的匹配守卫为假。
    接着 Rust 会前往第二个分支，这会匹配因为它没有匹配守卫所以会匹配任何 Some 成员。

    无法在模式中表达 if x < 5 的条件，所以匹配守卫提供了表现此逻辑的能力。
    */

    // 为了创建能够比较外部 x 和 y 的值，而不引入覆盖变量的 match 表达式，可以使用匹配守卫来解决模式中变量覆盖的问题：
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) => println!("Got 50"),
        // 匹配守卫 if n == y 并不是一个模式所以没有引入新变量。
        // 这个 y 正是 外部的 y 而不是新的覆盖变量 y，这样就可以通过比较 n 和 y 来表达寻找一个与外部 y 相同的值的概念了。
        Some(n) if n == y => println!("Matched, n = {}", n),
        _ => println!("Default case, x = {:?}", x),
    }

    println!("at the end: x = {:?}, y = {}", x, y);

    // 也可以在匹配守卫中使用 或 运算符 | 来指定多个模式，同时匹配守卫的条件会作用于所有的模式。
    let x = 4;
    let y = false;

    match x {
        // 这个匹配条件表明此分支值匹配 x 值为 4、5 或 6 同时 y 为 true 的情况。
        4 | 5 | 6 if y => println!("yes"),
        _ => println!("no"),
    }

    // ========================================================================
    // @ 绑定
    // ========================================================================
    // at 运算符（@）允许我们在创建一个存放值的变量的同时测试其值是否匹配模式。

    enum Msg {
        Hello { id: i32 },
    }

    let msg = Msg::Hello { id: 5 };

    /*
    这里我们希望测试 Msg::Hello 的 id 字段是否位于 3..=7 范围内，
    同时也希望能将其值绑定到 id_variable 变量中以便此分支相关联的代码可以使用它。
    可以将 id_variable 命名为 id，与字段同名，不过出于示例的目的这里选择了不同的名称。
    */

    match msg {
        Msg::Hello { id: id_variable @ 3..=7 } => {
            // 使用 @ 可以在一个模式中同时测试和保存变量值。
            println!("Found an id in range: {}", id_variable)
        },
        Msg::Hello { id: 10..=12 } => {
            println!("Found an id in another range")
        },
        Msg::Hello { id } => {
            println!("Found some other id: {}", id)
        },
    }
}
