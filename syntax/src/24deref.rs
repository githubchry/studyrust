/*
通过 Deref trait 将智能指针当作常规引用处理
实现 Deref trait 允许我们重载 解引用运算符（dereference operator）*（与乘法运算符或通配符相区别）。
通过这种方式实现 Deref trait 的智能指针可以被当作常规引用来对待，可以编写操作引用的代码并用于智能指针。
*/

// 为了体会默认情况下智能指针与引用的不同，让我们创建一个类似于标准库提供的 Box<T> 类型的智能指针。接着学习如何增加使用解引用运算符的功能。
// 从根本上说，Box<T> 被定义为包含一个元素的元组结构体：
struct MyBox<T>(T);     // MyBox 是一个包含 T 类型元素的`元组`结构体

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

// ========================================================================
// 通过实现 Deref trait 将某类型像引用一样处理
// ========================================================================
// Deref trait，由标准库提供，要求实现名为 deref 的方法，其借用 self 并返回一个内部数据的引用。
use std::ops::Deref;
impl<T> Deref for MyBox<T> {
    type Target = T;    // 语法定义了用于此 trait 的关联类型

    fn deref(&self) -> &T {
        &self.0     // 返回`值的引用`
    }
}
/*
Rust 将 * 运算符替换为先调用 deref 方法再进行普通解引用的操作，如此我们便不用担心是否还需手动调用 deref 方法了。
    let y = MyBox::new(x);
当我们在代码中输入 *y 时，Rust 事实上在底层运行了如下代码：
    *(y.deref())
Rust 的这个特性可以让我们写出行为一致的代码，无论是面对的是常规引用还是实现了 Deref 的类型。

deref 方法返回值的引用，以及 *(y.deref()) 括号外边的普通解引用仍为必须的原因在于所有权。
如果 deref 方法直接返回值而不是值的引用，其值（的所有权）将被移出 self。
在这里以及大部分使用解引用运算符的情况下我们并不希望获取 MyBox<T> 内部值的所有权。

注意，每次当我们在代码中使用 * 时， * 运算符都被替换成了先调用 deref 方法再接着使用 * 解引用的操作，且只会发生一次，不会对 * 操作符无限递归替换
 */
fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);


    // ========================================================================
    // 函数和方法的隐式解引用强制多态
    // ========================================================================
    /*
    解引用强制多态（deref coercions）是 Rust 在函数或方法传参上的一种便利。
    其将实现了 Deref 的类型的引用转换为原始类型通过 Deref 所能够转换的类型的引用。
    当这种特定类型的引用作为实参传递给和形参类型不同的函数或方法时，解引用强制多态将自动发生。
    这时会有一系列的 deref 方法被调用，把我们提供的类型转换成了参数所需的类型。

    解引用强制多态的加入使得 Rust 程序员编写函数和方法调用时无需增加过多显式使用 & 和 * 的引用和解引用。
    这个功能也使得我们可以编写更多同时作用于引用或智能指针的代码。
    */
    fn hello(name: &str) {
        println!("Hello, {}!", name);
    }

    let m = MyBox::new(String::from("Rust"));
    hello(&m);
    /*
    这里使用 &m 调用 hello 函数，其为 MyBox<String> 值的引用。
    因为已经在 MyBox<T> 上实现了 Deref trait，Rust 可以通过 deref 调用将 &MyBox<String> 变为 &String。
    标准库中提供了 String 上的 Deref 实现，其会返回字符串 slice，这可以在 Deref 的 API 文档中看到。
    Rust 再次调用 deref 将 &String 变为 &str，这就符合 hello 函数的定义了。

    如果 Rust 没有实现解引用强制多态，为了使用 &MyBox<String> 类型的值调用 hello，则不得不这样写：

        hello(&(*m)[..]);

    (*m) 将 MyBox<String> 解引用为 String。
    接着 & 和 [..] 获取了整个 String 的字符串 slice 来匹配 hello 的签名。
    没有解引用强制多态所有这些符号混在一起将更难以读写和理解。解引用强制多态使得 Rust 自动的帮我们处理这些转换。

    当所涉及到的类型定义了 Deref trait，Rust 会分析这些类型并使用任意多次 Deref::deref 调用以获得匹配参数的类型。
    这些解析都发生在编译时，所以利用解引用强制多态并没有运行时惩罚！
    */


    // ========================================================================
    // 解引用强制多态如何与可变性交互
    // ========================================================================
    /*
    类似于如何使用 Deref trait 重载不可变引用的 * 运算符，Rust 提供了 DerefMut trait 用于重载可变引用的 * 运算符。
    Rust 在发现类型和 trait 实现满足三种情况时会进行解引用强制多态：
        当 T: Deref<Target=U> 时从 &T 到 &U。
        当 T: DerefMut<Target=U> 时从 &mut T 到 &mut U。
        当 T: Deref<Target=U> 时从 &mut T 到 &U。
    头两个情况除了可变性之外是相同的：
    第一种情况表明如果有一个 &T，而 T 实现了返回 U 类型的 Deref，则可以直接得到 &U。
    第二种情况表明对于可变引用也有着相同的行为。
    第三个情况有些微妙：Rust 也会将可变引用强转为不可变引用。但是反之是 不可能 的：不可变引用永远也不能强转为可变引用。
    因为根据借用规则，如果有一个可变引用，其必须是这些数据的唯一引用（否则程序将无法编译）。
    将一个可变引用转换为不可变引用永远也不会打破借用规则。将不可变引用转换为可变引用则需要数据只能有一个不可变引用，而借用规则无法保证这一点。
    因此，Rust 无法假设将不可变引用转换为可变引用是可能的。
    */

}
