// ========================================================================
// 互斥器（mutex）一次只允许一个线程访问数据
// ========================================================================
/*
在某种程度上，任何编程语言中的通道都类似于单所有权，因为一旦将一个值传送到通道中，将无法再使用这个值。
共享内存类似于多所有权：多个线程可以同时访问相同的内存位置。
智能指针如何使得多所有权成为可能，然而这会增加额外的复杂性，因为需要以某种方式管理这些不同的所有者。
Rust 的类型系统和所有权规则极大的协助了正确地管理这些所有权。作为一个例子，让我们看看互斥器，一个更为常见的共享内存并发原语。

互斥器（mutex）是 mutual exclusion 的缩写，也就是说，任意时刻，其只允许一个线程访问某些数据。为了访问互斥器中的数据，线程首先需要通过获取互斥器的 锁（lock）来表明其希望访问数据。锁是一个作为互斥器一部分的数据结构，它记录谁有数据的排他访问权。因此，我们描述互斥器为通过锁系统 保护（guarding）其数据。

互斥器以难以使用著称，因为你不得不记住：
    1. 在使用数据之前尝试获取锁。
    2. 处理完被互斥器所保护的数据之后，必须解锁数据，这样其他线程才能够获取锁。

作为一个现实中互斥器的例子，想象一下在某个会议的一次小组座谈会中，只有一个麦克风。
如果一位成员要发言，他必须请求或表示希望使用麦克风。一旦得到了麦克风，他可以畅所欲言，然后将麦克风交给下一位希望讲话的成员。
如果一位成员结束发言后忘记将麦克风交还，其他人将无法发言。
如果对共享麦克风的管理出现了问题，座谈会将无法如期进行！

正确的管理互斥器异常复杂，这也是许多人之所以热衷于通道的原因。
然而，在 Rust 中，得益于类型系统和所有权，我们不会在锁和解锁上出错。
*/

// mpsc 是 多个生产者，单个消费者（multiple producer, single consumer）的缩写。
// Rust 标准库实现通道的方式意味着一个通道可以有多个产生值的 发送（sending）端，但只能有一个消费这些值的 接收（receiving）端。
use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    // 使用关联函数 new 来创建一个 Mutex<T>。
    let m = Mutex::new(5);

    {
        // 使用 lock 方法获取锁，以访问互斥器中的数据。这个调用会阻塞当前线程，直到我们拥有锁为止。
        // 如果另一个线程拥有锁，并且那个线程 panic 了，则 lock 调用会失败。
        // 在这种情况下，没人能够再获取锁，所以这里选择 unwrap 并在遇到这种情况时使线程 panic。
        let mut num = m.lock().unwrap();
        /*
        一旦获取了锁，就可以将返回值（在这里是num）视为一个其内部数据的可变引用了。
        类型系统确保了我们在使用 m 中的值之前获取锁：Mutex<i32> 并不是一个 i32，所以 必须 获取锁才能使用这个 i32 值。
        我们是不会忘记这么做的，因为反之类型系统不允许访问内部的 i32 值。
        */
        *num = 6;
        /*
        Mutex<T> 是一个智能指针。更准确的说，lock 调用 返回 一个叫做 MutexGuard 的智能指针。
        这个智能指针实现了 Deref 来指向其内部数据；也提供了一个 Drop 实现当 MutexGuard 离开作用域时自动释放锁，
        这正发生于内部作用域的结尾。为此，我们不会冒忘记释放锁并阻塞互斥器为其它线程所用的风险，因为锁的释放是自动发生的。
        */
        println!("m = {:?}", m);    // 此时还没解锁，无法打印互斥器的值 => m = Mutex { data: <locked> }
    }

    // 丢弃了锁之后，可以打印出互斥器的值，并发现能够将其内部的 i32 改为 6。
    println!("m = {:?}", m); // => m = Mutex { data: 6 }

    // ========================================================================
    // 在线程间共享 Mutex<T> => 原子引用计数 Arc<T>
    // ========================================================================
    /*
    Rc<T> 并不能安全的在线程间共享。当 Rc<T> 管理引用计数时，它必须在每一个 clone 调用时增加计数，并在每一个克隆被丢弃时减少计数。
    Rc<T> 并没有使用任何并发原语，来确保改变计数的操作不会被其他线程打断。
    在计数出错时可能会导致诡异的 bug，比如可能会造成内存泄漏，或在使用结束之前就丢弃一个值。
    我们所需要的是一个完全类似 Rc<T>，又以一种线程安全的方式改变引用计数的类型。

    所幸 Arc<T> 正是 这么一个类似 Rc<T> 并可以安全的用于并发环境的类型。
    字母 “a” 代表 原子性（atomic），所以这是一个原子引用计数（atomically reference counted）类型。
    （原子性还有另一类这里还未涉及到的并发原语：请查看标准库中 std::sync::atomic 的文档来获取更多细节。）
    其中的要点就是：原子性类型工作起来类似原始类型，不过可以安全的在线程间共享。

    为什么不是所有标准库中的类型都默认使用 Arc<T> 实现？
        ——线程安全带有性能惩罚，我们希望只在必要时才为此买单。如果只是在单线程中对值进行操作，原子性提供的保证并无必要，代码可以因此运行的更快。

    尝试使用 Mutex<T> 在多个线程间共享值。我们将启动十个线程，并在各个线程中对同一个计数器值加一，这样计数器将从 0 变为 10。
     */
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    for _ in 0..10 {
        /*
        for 前面创建 counter 三种方式：
            let counter = Mutex::new(0);            => 编译错误：counter 值在第一次循环中被移动了
            let counter = Rc::new(Mutex::new(0));   => 编译错误：Rc<T> 并不能安全的在线程间共享
            let counter = Arc::new(Mutex::new(0));  => 编译通过：原子性类型可以安全的在线程间共享

        原因看文末： => Sync 和 Send trait
        */
        let counter = Arc::clone(&counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();
            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("Result: {}", *counter.lock().unwrap());

    // ========================================================================
    // RefCell<T>/Rc<T> 与 Mutex<T>/Arc<T> 的相似性
    // ========================================================================
    /*
    你可能注意到了，因为 counter 是不可变的，不过可以获取其内部值的可变引用；这意味着 Mutex<T> 提供了内部可变性，就像 Cell 系列类型那样。
    正如27refcell.rs中使用 RefCell<T> 可以改变 Rc<T> 中的内容那样，同样的可以使用 Mutex<T> 来改变 Arc<T> 中的内容。

    另一个值得注意的细节是 Rust 不能避免使用 Mutex<T> 的全部逻辑错误。
    回忆一下28cycle_reference.rs 使用 Rc<T> 就有造成引用循环的风险，这时两个 Rc<T> 值相互引用，造成内存泄漏。
    同理，Mutex<T> 也有造成 死锁（deadlock） 的风险。
    这发生于当一个操作需要锁住两个资源而两个线程各持一个锁，这会造成它们永远相互等待。
    */


    // ========================================================================
    // Sync 和 Send trait
    // ========================================================================
    /*
    Send 标记 trait 表明类型的所有权可以在线程间传递。
    几乎所有的 Rust 类型都是Send 的，不过有一些例外，包括 Rc<T>：这是不能 Send 的，
    因为如果克隆了 Rc<T> 的值并尝试将克隆的所有权转移到另一个线程，这两个线程都可能同时更新引用计数。
    为此，Rc<T> 被实现为用于单线程场景，这时不需要为拥有线程安全的引用计数而付出性能代价。

    因此，Rust 类型系统和 trait bound 确保永远也不会意外的将不安全的 Rc<T> 在线程间发送。
    当尝试在上面中这么做的时候，会得到错误 the trait Send is not implemented for Rc<Mutex<i32>>。
    而使用标记为 Send 的 Arc<T> 时，就没有问题了。

    任何完全由 Send 的类型组成的类型也会自动被标记为 Send。几乎所有基本类型都是 Send 的，除了后面学习的裸指针（raw pointer）。

----------------------------------------------------------------------------------------------------

    Sync 标记 trait 表明一个实现了 Sync 的类型可以安全的在多个线程中拥有其值的引用。
    换一种方式来说，对于任意类型 T，如果 &T（T 的引用）是 Send 的话 T 就是 Sync 的，这意味着其引用就可以安全的发送到另一个线程。
    类似于 Send 的情况，基本类型是 Sync 的，完全由 Sync 的类型组成的类型也是 Sync 的。

    智能指针 Rc<T> 也不是 Sync 的，出于其不是 Send 相同的原因。
    RefCell<T> 和 Cell<T> 系列类型不是 Sync 的。所以RefCell<T> 在运行时所进行的借用检查也不是线程安全的。
    Mutex<T> 是 Sync 的，正如 “在线程间共享 Mutex<T>” 部分所讲的它可以被用来在多线程中共享访问。

----------------------------------------------------------------------------------------------------

    通常并不需要手动实现 Send 和 Sync trait，因为由 Send 和 Sync 的类型组成的类型，自动就是 Send 和 Sync 的。
    因为他们是标记 trait，甚至都不需要实现任何方法。他们只是用来加强并发相关的不可变性的，所以，手动实现 Send 和 Sync 是不安全的。
     */
}
