/*
实现一个增量式的发布博文的工作流。这个博客的最终功能看起来像这样：
    1.博文从空白的草案开始。
    2.一旦草案完成，请求审核博文。
    3.一旦博文过审，它将被发表。
    4.只有被发表的博文的内容会被打印，这样就不会意外打印出没有被审核的博文的文本。

任何其他对博文的修改尝试都是没有作用的。例如，如果尝试在请求审核之前通过一个草案博文，博文应该保持未发布的状态。


即便 Rust 能够实现面向对象设计模式，也有其他像将状态编码进类型这样的模式存在。这些模式有着不同的权衡取舍。
虽然你可能非常熟悉面向对象模式，重新思考这些问题来利用 Rust 提供的像在编译时避免一些 bug 这样有益功能。
在 Rust 中面向对象模式并不总是最好的解决方案，因为 Rust 拥有像所有权这样的面向对象语言所没有的功能。

mockblogex是用来演示rust特性怎么把面向对象的状态模式设计按在地上摩擦的....
*/

use mockblogex::Post;

fn main() {
    let mut post = Post::new();

    post.add_text("hello");

    // 因为 request_review 和 approve 返回新实例而不是修改被调用的结构体，所以我们需要增加更多的 let post = 覆盖赋值来保存返回的实例。
    // 也不再能断言草案和等待审核的博文的内容为空字符串了，我们也不再需要他们：不能编译尝试使用这些状态下博文内容的代码。

    let post = post.request_review();

    let mut post = post.reject();

    post.add_text(" world");

    let post = post.request_review();

    let post = post.approve();

    assert_eq!("hello world", post.content());

    /*
    不得不修改 main 来重新赋值 post 使得这个实现不再完全遵守面向对象的状态模式：状态间的转换不再完全封装在 Post 实现中。
    然而，得益于类型系统和编译时类型检查，我们得到了的是无效状态是不可能的！
    这确保了某些特定的 bug，比如显示未发布博文的内容，将在部署到生产环境之前被发现。
    */
}
